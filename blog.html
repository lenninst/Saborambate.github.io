<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Lenninst | Blog</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link rel="stylesheet" href="vendor/simple-line-icons/css/simple-line-icons.css">
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Catamaran:100,200,300,400,500,600,700,800,900" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli" rel="stylesheet">

  <!-- Plugin CSS -->
  <link rel="stylesheet" href="device-mockups/device-mockups.min.css">

  <!-- Custom styles for this template -->
  <link href="css/new-age.min.css" rel="stylesheet">

</head>

<body id="page-top">

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">Lenin Guaminga</a>
      <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        Menu
        <i class="fas fa-bars"></i>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html?#howim">Acerca de mi</a>
          </li>
          
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html?#contact">Contacto</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

 
  <section class="cta">
    <div class="cta-content">
            <div class="container">
              <h2>Introducción a la ingenieria de software</h2>
              
            </div>
          </div>
    <div class="overlay"></div>
  </section>
  <section class="download bg-primary text-center" >
    <div class="container">
      <div class="row">
        <div class="col-md-4 mx-auto">          
          <img src="img/blog_IS.jpg">
        </div>
        <div class="col-md-8 mx-auto">   
          <h2>Ingenieria de software</h2>       
          <p>La Ingeniería de Software Es una de las ramas de las ciencias de la computación que estudia la creación de software confiable y de calidad, basándose en métodos y técnicas de ingeniería. Brindando soporte operacional y de mantenimiento, el estudio de las aplicaciones de la ingeniería de software. Integra ciencias de la computación y las ciencias basicas cuyos orígenes se encuentran en la ingeniería.</p>
             <div class="overlay"></div>
  </section>
   <section class="download bg-primary text-center" >
    <div class="container">
        <div class="col-md-4 mx-auto">          
      
        </div>
        <div class="col-md-8 mx-auto">

          <h1 align="justify">Definición de IS</h1>
            <p align="justify">

                <p align="justify"> Fritza Bauer, 1969: Más que una disciplina o una parte del conocimiento, la Ingeniería
                    es un verbo, una palabra de acción, un modo de enfocar el problema. La Ingeniería del
                    Software es el establecimiento y uso de principios robustos de la ingeniería a fin de
                    obtener económicamente software que sea fiable y que funcione eficientemente sobre
                    maquinas reales.</p>

                <p align="justify">Bohem, 1976: Ingeniería del Software es la aplicación practica del conocimiento
                    científico en el diseño y construcción de programas de computadora y la documentación
                    necesaria requerida para desarrollar, operar (funcionar) y mantenerlos.

                    <p align="justify">Mills, 1980: La Ingeniería de Software tiene como uno de sus principales objetivos la
                        producción de programas que cumplan las especificaciones, y que se demuestren
                        correctos, producidos en el plazo y costo adecuado.</p>

                    <p align="justify">Meyer, 1988: La Ingeniería de Software es la producción de software de calidad.</p>

                    <p align="justify">IEEE 1993: La Ingeniería de Software es la aplicación de un enfoque sistemático,
                        disciplinado y cuantificable hacia el desarrollo, operación y mantenimiento del
                        software; es decir, la aplicación de Ingeniería de Software.</p>

                    <p align="justify">En resumen: La ingeniería de so-ware es una aplicación práctica del conocimiento
                        cientifico para proveer metodologías y técnicas que ayuden a desarrollar sistemas de
                        software a tiempo, y a su vez que aseguren que el desarrollador cumpla con las
                        expectativas de calidad y permanezca dentro del presupuesto. </p>
                </p>
                <h1 align="justify">Origen de la IS</h1>

                                Ingeniería del Software, es el término utilizado por Fritz Bauer en la primera
                                conferencia sobre desarrollo de software patrocinada por el Comité de Ciencia de la OTAN
                                celebrada en Garmisch (Alemania), en octubre de 1968, previamente había sido utilizado
                                por el holandés Edsger Dijkstra en su obra The Humble Programmer.

                                Puede definirse según Alan Davis como “la aplicación inteligente de principios probados,
                                técnicas, lenguajes y herramientas para la creación y mantenimiento, dentro de un coste
                                razonable, de software que satisfaga las necesidades de los usuarios”.
                                <br align="justify">
                                Su origen se debió a que el entorno de desarrollo de sistemas software adolecía de:<br>
                                <br align="justify">> Retrasos considerables en la planificación.
                                <br align="justify">> Poca productividad.
                                <br align="justify">> Retrasos considerables en la planificación.
                                <br align="justify">> Elevadas cargas de mantenimiento.
                                <br align="justify">> Demandas cada vez más desfasadas frente a las ofertas.
                                <br align="justify">> Baja calidad y fiabilidad del producto.
                                <br align="justify">> Dependencia de los realizadores.
                            </p>

                            <h1>Crisis del software</h1>
                            <p>
                                Primera Fase.<br><br> Los albores (1945-1955) <br>
                                Programar no es una tarea diferenciada del diseño de una máquina.
                                <br>Uso de lenguaje máquina y ensamblador.<br><br>
    
                                Segunda Fase.<br><br> El florecimiento (1955-1965)<br>
    
                                Aparecen multitud de lenguajes.
                                <br>Se pensaba que era posible hacer casi todo.<br><br>
    
                                Tercera Fase.<br><br> La crisis (1965-1970) <br>
    
                                Desarrollo inacabable de grandes programas. Ineficiencia, errores, costes impredecible.
                                <br>Nada es posible.<br><br>
    
                                Cuarta Fase.<br><br> Innovación Conceptual (1970-1980) <br>
    
                                Fundamentos de programación.
                                <br>Verificación de programas.
                                <br>Metodologías de diseño.<br><br>
    
                                Quinta Fase.<br><br> El diseño es el problema (1980-¿?)<br>
                                Entornos de programación.
                                <br>Especificación formal.
                                <br>Programación automática.
                            </p>

                            <br align="justify">
                            Metodologías ágiles: métodos de desarrollo de software basados en procesos iterativos e
                            incrementales, donde los requisitos y soluciones evolucionan durante la colaboración.<br>
                            Metodologías como Scrum (1995), Extreme Programming (1999) o DSDM (1995) fueron evolucionando
                            hasta que en Febrero del 2001 se publicó “Manifesto for Agile Software Development” para definir
                            la aproximación ahora conocida como metodologías ágiles.<br>
                            <br align="justify">Experimentación: es una rama de la ingeniería del software interesada en realizar
                            experimentos sobre software, recolectar datos y deducir leyes y teorías de los mismos.<br>
                            Desarrollo dirigido por modelos: primero se desarrollan modelos textuales gráficos del software
                            a construir, y posteriormente se construye el software.
                            <br align="justify">Líneas de productos software, en lugar de productos individuales.<br>
    
                            <br align="justify">Procesos de ingeniería en Software<br>
    
                            <br align="justify">Factores de calidad del software:<br>
                            <br align="justify">Concepto de Calidad: Conjunto de propiedades y de características de un producto o servicio,
                            que le confieren aptitud para satisfacer una necesidad explícita o implícita (ISO 8402).<br>
                            <br align="justify">Calidad del Software: Es el grado con el que un sistema, componente o proceso cumple los
                            requerimientos especificados y las necesidades o expectativas del cliente o usuario.<br>
    
                            <br align="justify">Los factores que determinan la calidad del software se puede clasificar en dos grandes
                            grupos (Pressman):<br>
                            <br align="justify">Medidas Directas: La medida o medición decimos que es directa, cuando disponemos de un
                            instrumento de medida que nos muestra un resultado (generalmente numérico).<br>
                            <br align="justify">Medidas Indirectas: Cuando hablamos de sistemas informáticos no siempre es posible realizar
                            una medida directa, porque no disponemos del instrumento adecuado que nos permita realizar esa
                            medición.<br>

                            <h1 align="left">Entre las métricas del software tenemos las siguientes:</h1>
                        <br align="left">Métricas técnicas: Se centran en las características del software. Aquí medimos la
                        complejidad lógica y el grado de modularidad del sistema. Mide la estructura del sistema, el
                        cómo está hecho.<br>
                        <br align="left">Métricas de calidad: Son todas las métricas de software que definen de una u otra forma la
                        calidad del software; tales como corrección, exactitud, integridad, facilidad de uso,
                        estructuración o modularidad, pruebas, facilidad de mantenimiento, reusabilidad, cohesión del
                        módulo, acoplamiento del módulo, etc.<br>
                        <br align="left">Estas son los puntos críticos en el diseño, codificación, pruebas y mantenimiento.
                        Proporcionan una indicación de cómo se ajusta el software a los requisitos implícitos y
                        explícitos del cliente. Es decir cómo voy a medir para que mi sistema se adapte a los requisitos
                        que me pide el cliente.<br>
                        <br align="left"> Corrección: es el grado en que el software desempeña la función para la que fue creado y se
                        mide en defectos por KLDC.<br>
                        <br align="left">Facilidad de Mantenimiento: es la sencillez con que un programa puede corregirse si se
                        encuentra un error, al adaptarse si su entorno cambio o mejorar si el cliente cambia los
                        requisitos y se mide en forma indirecta en TMC (Tiempo Medio de Cambio).<br>
                        <br align="left">Integridad: es la habilidad de un sistema para resistir ataques que requiere la definición
                        de amenaza y seguridad y se calcula: integridad = 1 – (amenaza * (1 – seguridad)).<br>
                        <br align="left">Facilidad de uso: Es el intento por cuantificar la sencillez de una aplicación al
                        utilizarla.<br>
                        <br align="left">Métricas de calidad: Se centran en el rendimiento del proceso de la ingeniería del software.
                        Es decir qué tan productivo va a ser el software que voy a diseñar. Se refiere a las
                        características del software.<br>
                        <br align="left">Métricas de costo: se centra en el costo total del sistema informático.<br>
                        <br align="left">Métricas orientadas al tamaño: Esta nos permite conocer el tiempo en el que se terminará el
                        software y cuántas personas se necesitan para su desarrollo, aquí medimos las variables con las
                        que desarrollamos el software.<br>
                        <br align="left">Métricas orientadas a la función o puntos de función: Son medidas indirectas del software y
                        del proceso por el cual se desarrolla.

                        <br><br> <h1>El Software puede dividirse en dos grandes grupos:</h1><br>
                        <br align="left">Software de aplicaciones: se usan para proveer servicios aclientes y ejecutar negocios de
                        forma más eficiente. El software
                        de aplicaciones puede ser un sistema pequeño o uno grande integrado. Ejemplos de Software de
                        aplicaciones
                        sistema de cuentas, un sistema de planificación de recursos...<br>
                        <br align="left">Software de sistemas: El software de sistemas se usa para
                        operar y mantener un sistema informático. Permite a los
                        usuarios usar los recursos del ordenador directamente y a
                        través de otro software. Algunos ejemplos de este tipo de
                        software son los sistemas operativos, compiladores y otras
                        utilidades del sistema.<br>
                        <br align="left">El software se desarrolla, no se fabrica en el sen7do clásico de
                        la palabra. Ambas actividades se dirigen a la construcción de un
                        "producto", pero los métodos son diferentes. Los costes del
                        software se encuentran en la ingeniería, esto implica que los
                        proyectos no se pueden gestionar como si lo fueran de
                        fabricación.<br>

                        <br align="left"> En el software, el recurso principal son las personas. No es
                        siempre posible acelerar la construcción de software añadiendo
                        personas porque la construcción de software requiere un
                        esfuerzo en equipo. El equipo tiene que trabajar de forma
                        coordinada y comparar un objetivo de proyecto común. Se
                        necesita comunicación efectiva dentro del equipo.<br>

                        <br align="left">El software no se estropea, pero se deteriora. Durante su vida,
                        el software sufre cambios (mantenimiento). Conforme se hacen
                        los cambios, es bastante probable que se introduzcan nuevos
                        defectos, lo que hace que el so-ware se vaya deteriorando
                        debido a estos cambios.<br>


                        <h1>Mantenimiento</h1>
                        <p>
                                <br>Comienza una vez construido el sistema.  <br>
                                <br>Se centra en el cambio.  <br>
                                <br>El software es sometido a reparaciones y modiﬁcaciones cada vez que se detecta un fallo o se necesita cubrir una nueva necesidad de los usuarios.<br> 
                                <br>En esta fase recae el mayor porcentaje del costo de un sistema.  <br>
                                <br>Un buen sistema no es sólo un conjunto de programas que funcionan bien => Debe ser fácil de mantener <br>
                        <br><br><h1>Tipos de mantenimiento</h1><br>
                        <br>Correctivo: El programa no funciona correctamente, hay que modiﬁcarlo. <br>
                        <br>Perfectivo: Se modiﬁca el programa para obtener más eﬁciencia o nuevas funcionalidades no especiﬁcadas en la deﬁnición del sistema. <br>
                        <br>Adaptativo: Adaptar el programa a los cambios en su entorno (cambio de SO,de CPU,de legislación,…) <br>
                        <br>Preventivo: El software se deteriora con los cambios, este mantenimiento hace cambios para que los programas se puedan corregir, adaptar y mejorar más rápidamente -> Reingeniería del SW<br>

                        </p>

                        <h1>Sistemas de información</h1>
                        <p>
                                <br>Un sistema de información realiza cuatro actividades básicas: entrada, almacenamiento, procesamiento y salida de información(Peralta,2008). <br>
                                <br>Entrada de Información: Es el proceso mediante el cual el Sistema de Información toma los datos que requiere para procesar la información.<br>
                                <br>Almacenamiento de información:El almacenamiento es una de las actividades o capacidades más importantes que tiene una computadora, ya que a través de esta propiedad el sistema puede recordar la información guarda da en la sección o proceso anterior.<br>
                                <br>Procesamiento de Información: Es la capacidad del Sistema de Información para efectuar cálculos de acuerdo con una secuencia de operaciones preestablecida. <br>
                                <br>Salida de Información: La salida es la capacidad de un Sistema de Información para sacar la información procesada o bien datos de entrada al exterior.<br>
                        <br><h1>Tipos de Sistemas de información</h1>
                        <br>Sistemas transaccionales: Son Sistemas de Información que logran la automatización de procesos operativos dentro de una organización ya que su función primordial consiste en procesar transacciones tales como pagos, cobros, entradas, salidas, etc.<br>
                        <br>Sistemas de Soporte a la Toma de Decisiones, Sistemas para la Toma de Decisión de Grupo, Sistemas Expertos de Soporte a la Toma de Decisiones y Sistema de Información para Ejecutivos: Son Sistemas de Información que apoyan el proceso de toma de decisiones.<br>
                        <br>Sistemas Estratégicos: Son sistemas de información desarrollado en las organizaciones con el ﬁn de lograr ventajas competitivas, a través del uso de la tecnología de información.<br>

                        <h1>Ciclo de vida</h1>
                        <p>
                                <br>Se puede deﬁnir ciclo de vida del software como:<br>
                                <br>El ciclo de vida del software consiste de las siguientes fases: análisis de requisitos, diseño, implementación, prueba y mantenimiento.<br>
                                <br>El proceso dedesarrollo tiende a una iteración de estas fases más que a un proceso lineal [CERN,1996]. <br>
                                <br>El ciclo de vida del software usa el modelo de que un elemento software tiene vida. <br>
                                <br>Un elemento software tiene una fase de concepción (una idea en una mente de un usuario potencial), después de una fase de gestación (la fase de desarrollo del software ) hacia una fase de madurez (la revisión y corrección de errores, o fase de mantenimiento), y ﬁnalmente la fase de retirada[Leaney,2004]<br>

                                <br>Desde un punto de vista general puede considerarse que el ciclo de vida de un software tiene tres etapas claramente diferenciadas:<br>
                                <br>Planiﬁcación:idearemos un planeamiento detallado que guíe la gestión del proyecto,temporal y económicamente.<br>
                                <br>Implementación: acordaremos el conjunto de actividades que componen la realización del producto.<br>
                                <br>Puesta en producción: nuestro proyecto entra en la etapa de deﬁnición, allí donde se lo presentamos al cliente o usuario ﬁnal, sabiendo que funciona correctamente y responde a los requerimientos solicitados en su momento. Esta etapa es muy importante no sólo por representar la aceptación o no del proyecto
                                por parte del cliente o usuario ﬁnal sino por las múltiples diﬁcultades que suele presentar en la práctica, alargándose excesivamente y provocando costos no previstos.<br>
                        </p>
      <div class="overlay"></div>
   </section>
   <section class="download bg-primary text-center" >
    <div class="container">
      <div class="row">
    
        <div class="col-md-8 mx-auto">  
          <div class="container">
        <div class="row mb-5 justify-content-center">
          <div class="col-md-8 text-center">
            <h2 class="section-title mb-3" data-aos="fade-up" data-aos-delay="">Unidad II</h2>
            <p class="lead" data-aos="fade-up" data-aos-delay="100">Modelo del proceso Software.</p>
          </div>
        </div>
        <div class="row">
          
          <div class="col-lg-12 ml-auto" data-aos="fade-up" data-aos-delay="100">
            
            <h1>Modelo de proceso de Software</h1>
            <p>
                Hay varios modelos de procesos definidos en la bibliografía de Ingeniería del Software<br>
                <br>Cada modelo de proceso representa un proceso desde una perspectiva particular, por lo
                que sólo ofrece una información parcial sobredicho proceso.<br>
                <br>Hay varios modelos de procesos definidos en la bibliografía de Ingeniería del
                Software<br>
                <br>Cada modelo de proceso representa un proceso desde una perspectiva particular, por lo
                que sólo ofrece una información parcial sobredicho proceso.<br>
                <br><br>Razones para modelar un proceso de SW<br><br>
                <br>Cuando se pone por escrito una descripción de un proceso, se da forma a una
                comprensión común de las actividades, recursos y restriccionesrelacionados conel
                desarrollo del software.<br>
                <br>Ayuda al equipo de desarrollo a encontrar las inconsistencias, las redundancias y las
                omisiones en el proceso y en las partes que lo constituyen.<br>
                <br>El modelo debe reflejar las metas del desarrollo. A medida que se construye el modelo el
                equipo de desarrollo evalúa las actividades candidatas por su adecuación para alcanzar
                dichas metas.<br>
                <br>Ayuda al equipo de desarrollo a comprender dónde debe adaptarse el proceso<br>
                <br>Los modelos de proceso de desarrollo de software incluyen los requisitos del sistema
                como entrada y un producto entregado comosalida<br>
            </p>

            <h1>Modelo de proceso de Software</h1>
                        <p>
                            <br>Especificación: <br><br> Formulación de los requisitos y restricciones del sistema<br>
                            <br>Diseño: <br>
                            <br>Elaboración de un documento con el modelo del sistema:<br>
                            <br>Fabricación: <br>
                            <br>Construcción del sistema<br>
                            <br>Prueba: <br>
                            <br>Comprobación de que el sistema cumple las especificaciones requeridas<br>
                            <br>Instalación: <br>
                            <br>Entrega del sistema al cliente y garantía de que es operativo<br>
                            <br>Mantenimiento: <br>
                            <br>Reparación de los fallos que aparecen en el sistema<br>
                            <br>Fase de definición: <br>
                            <br>Se identifican los requisitos claves del sistema y del software <br>
                            <br>Se desarrolla: <br>
                            <br>Un Análisis de Sistemas <br>
                            <br>Se define el papel de cada elemento en el sistema automatizado: <br>
                            <br>de información,incluyendoelquejugaráel software <br>
                            <br>Un Análisis de Requisitos: <br>
                            <br>Se especifican todos los requisitos de usuario que el sistema tiene que satisfacer <br>
                            <br>Esta fase está orientada al QUÉ: <br>
                            <br>Qué información ha de ser procesada, qué función y rendimiento se desea, qué
                            interfaces han de establecerse, qué ligaduras de diseño existen y qué criterios de
                            validación se necesitan para definir un sistema correcto<br>
                            <br><br>Fase de definición <br>
                            <br>Existe un paso complementario: la planificación del proyecto software: <br>
                            <br>Se asignanlos recursos <br>
                            <br>Se estimanlos costos <br>
                            <br>Se planifican las tareas y el trabajo<br>
                            <br>Fase de desarrollo<br>
                            <br>Fase orientada al CÓMO <br>
                            <br>El primer paso de esta fase corresponde al Diseño del Software <br>
                            <br>Se trasladan los requisitos del software a un conjunto de representaciones que describen
                            la estructura de datos, arquitectura del software y procedimientos algorítmicos que
                            permiten la construcción física de dicho software.<br>
                            <br>Los otros dos pasos de la fase de desarrollo corresponden a la Codificación y a la
                            Prueba del Software<br>
                            <br><br>Fase de mantenimiento <br>
                            <br>Mantenimiento correctivo<br>
                            <br>Corrección de errores<br>
                            <br>Mantenimiento adaptativo<br>
                            <br>Adaptacionesrequeridas por la evolución del entorno del software <br>
                            <br>Mantenimiento perfectivo <br>
                            <br>Las modificaciones debidas a los cambios de requisitos del usuario para mejorar el
                            sistema <br>
                            <br>Mantenimiento preventivo<br>
                            <br>Mejora de las características internas del producto para hacer más mantenible<br>
                        </p>

                        <h1>Modelos de proceso de Software</h1>
                        <p>
                           <br> El modelo de cascada <br>
                           <br>Modelo de Plan-impulsado.<br>
                           <br>Fases separadas y distintas de especificacióny desarrollo.<br>
                           <br>El desarrollo incremental<br>
                           <br>Especificación, desarrollo y validación se intercalan. Puede ser el plan impulsado ágil.<br>
                           <br>Ingeniería de software orientado a reutilización <br>
                           <br>El sistema se ensambla a partir de componentes existentes. Puedeser el plan impulsado o ágil.<br>
                           <br>En la práctica, la mayoría de los grandes sistemas se desarrollan mediante un proceso que incorpora elementos de todos estos modelos.<br>
                        </p>

                        <h1>Modelo Cascada</h1>
                        <p>
                            <br>Las fases están identificadas por separado: <br>
                            <br>Elanálisis y definiciónde requerimientos <br>
                            <br>Diseño del sistema y software. <br>
                            <br>Pruebas de implementación de unidades <br>
                            <br>Integracióny pruebas del sistema<br>
                            <br>Operación y mantenimiento<br>
                            <br>El principal inconveniente del modelo de la cascada es la dificultad de acomodar el cambio después de que está en marcha el proceso. En principio, una fase tiene que ser completadaantesde pasar a la siguiente fase.<br>
                            <br><br>Problemas del Modelo de Cascada: <br><br>
                            <br>Inflexible división del proyecto en fases distintas hace que sea difícil responder a las necesidades cambiantes de los clientes. <br>
                            <br>Por lo tanto, este modelo sólo es apropiado cuando los requisitos son bien entendidos y los cambios serán bastante limitados durante el proceso de diseño. <br>
                            <br>Pocos sistemas tienen requisitos estables. <br>
                            <br>El modelo de cascada se utiliza sobre todo para los grandes proyectos de ingeniería de sistemas en que un sistema se desarrolla en varios lugares<br>
                        </p>

                        <h1>Desarrollo incremental</h1>
                        <p>
                             <br>Beneficios:<br>
                             <br>El costo de atender las necesidades cambiantes de los clientes sereduce. <br>
                             <br>La cantidad de análisis y la documentación que tiene que ser hecho de nuevo es mucho menor que la que se requiere con el modelo de cascada. <br>
                             <br>Es más fácil obtener retroalimentación de los clientes en el trabajo de desarrollo que se ha hecho. <br>
                             <br>Los clientes pueden hacer comentarios sobre las manifestaciones del software y ver cuánto se ha implementado.<br>
                             <br>Más rápida entrega y despliegue de software de utilidad para el clienteesposible. <br>
                             <br>Los clientes pueden usar y obtener valor a partir del software anterior que es posible con un proceso de cascada.<br>
                             <br><br>Problemas: <br>
                             <br>El proceso no es visible. <br>
                             <br>Los gerentes necesitan entregas regulares para medir el progreso.<br>
                             <br>Si se desarrollan rápidamente los sistemas, no es rentable para producir documentos que reflejen todas las versiones del sistema. <br>
                             <br>Estructura del sistema tiende a degradarse a medida que se añaden nuevos incrementos. <br>
                             <br>A menos tiempo y dinero que se gasta en la refactorización para mejorar el software, cambio regular tiende a corromper su estructura. La incorporación de nuevos cambios de software se vuelve cada vez más difícil y costoso.<br>
                        </p>

                        <h1>Espiral</h1>
                        <p>
                           <br> En este modelo, el esfuerzo de desarrollo es iterativo. <br>
                           <br>Tan pronto como uno completa un esfuerzo de desarrollo, otro comienza. Además, en cada desarrollo ejecutado, puedes seguir estos cuatros pasos. <br>
                           <br> 1. Determinar qué quieres lograr. <br>
                           <br>2. Determinar las rutas alternativas que puedes tomar para lograr estas metas. Por cada una, analizar los riesgos y resultados finales, y seleccionar la mejor. <br>
                           <br> 3. Seguir laalternativa seleccionada en el paso 2. <br>
                           <br>4. Establecer qué tienes terminado. <br>
                           <br>El Modelo Espiral mejora el Modelo de Cascada enfatizando la naturaleza iterativa del proceso de diseño. Eso introduce un ciclo de prototipo iterativo. En cada iteración, las nuevas expresiones que son obtenidas transformando otras dadas son examinadas para ver sirepresentanprogresos hacia el objetivo.<br>
                           <br><br>Características: <br>
                           <br>En cada giro se construye un nuevo modelo del sistema completo. <br>
                           <br>Este modelo puede combinarse con otros modelos de procesode desarrollo (cascada,evolutivo). <br>
                           <br>Mejor modelo para el desarrollo de grandes sistemas. <br>
                           <br>El análisis de riesgo requiere la participación de personal altamente calificado.<br>
                        </p>

                        <h1>Desarrollo Rápido de Aplicaciones</h1>
                        <p>
                            <br>El modelo DRA es una adaptación a alta velocidad del ciclo de vida clásico en el que se logra el desarrollo rápido utilizando un enfoque de construcción basado en componentes. Si se comprenden bien los requisitos y se limita el ámbito del proyecto, el proceso DRA permite al equipo de desarrollo crear un sistema completamente funcional dentro de períodos cortos de tiempo.<br>
                            <br>Cuando se utiliza principalmente para aplicaciones de sistemas de información, el enfoque DRA comprende las siguientesfases: 
                            <br>Modelado de gestión: El flujo de información entre las funciones de gestión se modela de forma que responda a las siguientes preguntas: ¿Qué información conduce el proceso de gestión? ¿Qué información se genera? ¿Quién la genera? ¿A dónde va lainformación? ¿Quién la procesa? <br>
                            <br>Modelado de datos: El flujo de información definido como parte de la fase de modelado de gestión refina como un conjunto de objetos de datos necesarios para apoyar la empresa. Se definen las características de cada uno de los objetos y relaciones entre estos objetos.<br>
                            <br>Modelado de procesos: Los objetos de datos definidos en la fase de modelado de datos quedan transformados para lograr el flujo de información necesario para implementar una función de gestión. Las descripciones se crean para añadir, modificar, suprimir, o recuperar un objetode datos. <br>
                            <br>Generación de aplicaciones: El DRA asume la utilización de técnicas de cuarta generación. En lugar de crear software con lenguajes de programación de tercera generación, el proceso DRA trabaja para volver a utilizar componentes de programas ya existentes (cuando es posible) o a crear componentes reutilizables (cuando sea necesario). En todos los casos se utilizan herramientas automáticas para facilitar.<br>
                            <br>Prueba y entrega: Como el proceso DRA enfatiza la reutilización, ya se han comprobado muchos de los componentes de los programas. Esto reduce tiempo de pruebas. Sin embargo, se deben probar todos los componentes nuevos y se deben ejercitar todas las interfaces a fondo.<br>
                        
                        </p>
                        <h1>Orientados a la reutilización</h1>
                        <p>
                            <br>El proceso tiende a estructurarse en dos subprocesos distintosy separados:<br>
                            <br>El desarrollo para reutilización: construcción de elementos reutilizables dentro de un dominio concreto.<br>
                            <br>El desarrollo con reutilización: construcción de aplicaciones utilizando elementos reutilizables.<br>
                            <br><br>Etapas del proceso <br>
                            <br>• Análisis de los componentes; <br>
                            <br>• Requisitos de modificación; <br>
                            <br>• Configuración del sistema con lareutilización; <br>
                            <br>• Desarrollo e integración. <br>
                            <br>• La reutilización es ahora el enfoque estándar para la construcciónde muchostipos de sistemasde negocio<br>
                        </p>

                        <h1>Orientado a Objetos</h1>
                        <p>
                            <br>La definición del modelado orientado a objetos puede claramentedividir el enfoque en tres dimensiones: <br>
                            <br>• La dimensión estructural.<br>
                            <br>• La dimensión dinámica.<br>
                            <br>• La dimisión funcional.<br>
                            <br>Este tipo de modelado implica la realización de las siguientesactividades:<br>
                            <br>1. Identificar lasclases, modelos y objetos. (objetos y atributos).
                             <br>2. Asociar estáticamente los objetos. (relaciones dependientes del dominio del problema).
                             <br>3. Especificación del comportamiento de los objetos. (Definir como se comportaran los objetos). 4. Definir la jerarquía de herencia de las clases. (Definir la jerarquía de clases, para que el sistema quede lo más abstracto posible).<br>
                             <br><br>Características: <br>
                             <br>• EL modelado Orientado a Objetos está basado en el paradigma orientadoa objetos. <br>
                             <br>• Trata el almacenamiento de objetos (persistencia de los objetos). <br>
                             <br>• Define un lenguaje para le definición y manipulación de objetos.<br>
                             <br>• Incluye mecanismos para optimizar el acceso (Indexación y Clustering), el control de la concurrencia, seguridad y gestión de usuarios, facilidad de consulta y recuperación antefallos. <br>
                        </p>

       <div class="col-md-4 mx-auto">
        </div>
      </div>
    </div>
  </section>
  <section class="contact bg-primary" id="contact">
    <div class="container">
      <h2> También, puedes seguirme en  
        mis redes sociales!
      <i class=""></i></h2>
      <ul class="list-inline list-social">
        <li class="list-inline-item social-twitter">
          <a href="https://twitter.com/LennynStalyng" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        </li>
        <li class="list-inline-item social-facebook">
          <a href="https://m.facebook.com/lennistalyn" target="_blank">
            <i class="fab fa-facebook-f"></i>
          </a>
        </li>
        <li class="list-inline-item social-instagram">       
          <a href="https://www.instagram.com/lenninst/" target="_blank">
          <i class="fab fa-instagram"></i>
          </a>    
        </li>
        <li class="list-inline-item social-github">       
          <a href="https://github.com/lenninst" target="_blank">
          <i class="fab fa-github"></i>
          </a>    
        </li>
      </ul>
    </div><br><br>
    <h3>leninguaminga@gmail.com</h3>
  </section>

  <footer>
    <div class="container">
      <p>&copy; Your Website 2019. All Rights Reserved.</p>
      <ul class="list-inline">
        <li class="list-inline-item">
          <a href="#">Privacy</a>
        </li>
        <li class="list-inline-item">
          <a href="#">Terms</a>
        </li>
        <li class="list-inline-item">
          <a href="#">FAQ</a>
        </li>
      </ul>
    </div>
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/new-age.min.js"></script>

</body>

</html>
